# Leo HITL Dashboard - Project Documentation

## Project Summary

The Leo Human-in-the-Loop (HITL) Dashboard is a web-based internal tool that enables human reviewers to monitor, approve, or deny SMS messages generated by the Leo AI agent before they are sent to end users. The dashboard serves as a critical quality control checkpoint in the RSVP outreach workflow, ensuring brand safety, message quality, and user engagement optimization.

### Core Business Goal

Increase RSVPs to social dining events while maintaining human oversight over message quality, safety, and brand alignment. The dashboard enables scalable AI-powered outreach with human judgment at the decision point.

### Strategic Context

**The Challenge:** Manual outreach is unscalable, but fully automated AI risks brand safety and "hallucinations."

**The Solution:** A centralized dashboard acting as a firewall. It leverages Firebase Realtime Database to sync upstream agent generation with downstream execution, gated by human review.

**The Closed Loop:** Approved messages drive revenue (RSVPs), while denied messages generate structured training data to improve the model.

---

## Campaign-Specific Dashboards

### Overview

For the Monday, December 16, 2025 campaign execution, we need to create three campaign-specific dashboards. Each dashboard will be modeled after the existing `dashboard.html` but will filter data by the `campaign` field instead of showing all data.

**Firebase Structure:**
- All campaigns save to `/Leo/` paths (same as main dashboard)
- Each record (user, event, match, message) includes a `campaign` field for filtering:
  - `campaign: 'fill-the-table'`
  - `campaign: 'return-to-table'`
  - `campaign: 'seat-newcomers'`

Each campaign dashboard will:
- Filter data by `campaign` field
- Provide insights into:
  - User selection (how users were chosen)
  - Event selection (why these events)
  - Matching process (how users were matched to events)
  - Message generation (all generated messages)

---

## Dashboard Creation Plan

### 1. Fill The Table Dashboard

**File:** `apps/dashboard/fill-the-table.html`

**Firebase Path:** `/Leo/` (same as main dashboard)

**Based On:** `dashboard.html` (use as template)

**Key Differences from Main Dashboard:**
- Filters all data by `campaign: 'fill-the-table'` field
- Campaign-specific title: "Fill The Table Campaign Dashboard"
- Displays 50 users, 50 messages (filtered by campaign)
- Campaign-specific metrics and insights

**Features:**

**A. User Selection Insights:**
- Display all 50 selected users
- Show user ranking criteria:
  - Event count (primary ranking factor)
  - Profile completeness
  - Why each user was selected
- User score/ranking visualization
- Profile completeness distribution chart
- Event count distribution chart

**B. Event Selection Insights:**
- Display all underfilled events targeted
- Show event selection criteria:
  - Fill percentage (<50% capacity)
  - Event date (urgency - soonest first)
  - Why each event was prioritized
- Event fill rate visualization
- Urgency score visualization

**C. Matching Insights:**
- Display all user-event matches
- For each match, show:
  - User details
  - Event details
  - Matching confidence score
  - Matching reasoning
  - Interest alignment analysis
  - Location proximity analysis
- Matching algorithm explanation
- Confidence score distribution

**D. Message Generation Insights:**
- Display all 50 generated messages
- For each message, show:
  - Message text
  - User details
  - Event details
  - Personalization notes
  - Character count
  - Message status (pending/approved/denied/sent)
- Message quality metrics
- Personalization elements used

**E. Campaign Metrics:**
- Total users processed: 50
- Total events matched: X
- Total messages generated: 50
- Average confidence score
- Average message length
- Profile completeness distribution
- Event fill rate improvements

**Navigation:**
- Link to other campaign dashboards
- Link back to main Leo dashboard

---

### 2. Return To Table Dashboard

**File:** `apps/dashboard/return-to-table.html`

**Firebase Path:** `/Leo/` (same as main dashboard)

**Based On:** `dashboard.html` (use as template)

**Key Differences from Main Dashboard:**
- Filters all data by `campaign: 'return-to-table'` field
- Campaign-specific title: "Return To Table Campaign Dashboard"
- Displays 16 users, 16 messages (filtered by campaign)
- Campaign-specific metrics and insights

**Features:**

**A. User Selection Insights:**
- Display all 16 selected users
- Show reactivation scoring:
  - Profile completeness (0-40 points)
  - Dormancy duration (0-30 points)
  - Event history (0-30 points)
  - Total reactivation score
- Show why each user was selected
- Dormancy duration visualization
- Event history visualization
- Reactivation score distribution

**B. Event Selection Insights:**
- Display all well-attended events targeted
- Explain why well-attended events (>80% filled) for social proof
- Show event participation rates
- Event quality metrics

**C. Matching Insights:**
- Display all user-event matches
- Show matching reasoning (welcome back messaging)
- Show interest alignment
- Show location proximity
- Confidence score distribution

**D. Message Generation Insights:**
- Display all 16 generated messages
- Show "welcome back" personalization
- Show references to past event attendance
- Message quality metrics

**E. Campaign Metrics:**
- Total users processed: 16
- Average reactivation score: 68.9
- Average dormancy: 60.1 days
- Average event history: 20.6 events
- Total messages generated: 16

**Navigation:**
- Link to other campaign dashboards
- Link back to main Leo dashboard

---

### 3. Seat Newcomers Dashboard

**File:** `apps/dashboard/seat-newcomers.html`

**Firebase Path:** `/Leo/` (same as main dashboard)

**Based On:** `dashboard.html` (use as template)

**Key Differences from Main Dashboard:**
- Filters all data by `campaign: 'seat-newcomers'` field
- Campaign-specific title: "Seat Newcomers Campaign Dashboard"
- Displays 34 users, 34 messages (filtered by campaign)
- Campaign-specific metrics and insights

**Features:**

**A. User Selection Insights:**
- Display all 34 selected users
- Show newcomer scoring:
  - Event history (0-50 points) - 0 events = highest priority
  - Profile completeness (0-30 points)
  - Account recency (0-20 points)
  - Total newcomer score
- Show why each user was selected (first-timer conversion potential)
- Account recency visualization
- Event history distribution (0 vs 1-2 events)
- Newcomer score distribution

**B. Event Selection Insights:**
- Display all welcoming events targeted (50-80% filled)
- Explain why welcoming events (social proof without exclusivity)
- Show event participation rates
- Beginner-friendly event indicators

**C. Matching Insights:**
- Display all user-event matches
- Show matching reasoning (beginner-friendly, welcoming)
- Show interest alignment
- Show location proximity
- Confidence score distribution

**D. Message Generation Insights:**
- Display all 34 generated messages
- Show "welcome" and "first event" personalization
- Show beginner-friendly messaging
- Message quality metrics

**E. Campaign Metrics:**
- Total users processed: 34
- Average newcomer score: 89.3
- First-timers (0 events): X
- Average profile completeness: 6.7/8
- Total messages generated: 34
- Account recency distribution

**Navigation:**
- Link to other campaign dashboards
- Link back to main Leo dashboard

---

## Implementation Details

### Common Features Across All Campaign Dashboards

1. **Firebase Integration:**
   - Connect to respective Firebase paths (`campaigns/{campaign-name}/`)
   - Real-time data updates (polling every 30 seconds)
   - Error handling for connection issues
   - Same Firebase URL as main dashboard

2. **Data Visualization:**
   - Charts for distributions (Chart.js or similar)
   - Score visualizations
   - Progress indicators
   - Status badges

3. **User Experience:**
   - Clean, modern UI (use Tailwind CSS like existing dashboard)
   - Responsive design
   - Loading states
   - Error messages
   - Search/filter capabilities

4. **Navigation:**
   - Links to other campaign dashboards
   - Link back to main Leo dashboard
   - Consistent navigation structure

### Technical Requirements

**Base Template:** Use `dashboard.html` as the starting point

**Key Changes to Make:**

1. **Add Campaign Filtering:**
   ```javascript
   // In dashboard.html, add campaign filter constant:
   const CAMPAIGN_FILTER = 'fill-the-table';  // or 'return-to-table', 'seat-newcomers'
   
   // When loading data, filter by campaign field:
   const filteredMessages = messages.filter(m => m.campaign === CAMPAIGN_FILTER);
   const filteredUsers = users.filter(u => u.campaign === CAMPAIGN_FILTER);
   const filteredEvents = events.filter(e => e.campaign === CAMPAIGN_FILTER);
   const filteredMatches = matches.filter(m => m.campaign === CAMPAIGN_FILTER);
   ```

2. **Update Title:**
   ```html
   <!-- Change dashboard title to campaign-specific -->
   <h1 class="text-2xl font-bold text-gray-900">Fill The Table Campaign Dashboard</h1>
   ```

3. **Add Campaign-Specific Sections:**
   - User Selection Insights section
   - Event Selection Insights section
   - Matching Insights section
   - Message Generation Insights section
   - Campaign Metrics section

4. **Update Data Fetching:**
   - All Firebase reads should use the campaign-specific path
   - Same structure as main dashboard (users, events, matches, messages arrays)

5. **Add Navigation Links:**
   - Add links to other campaign dashboards in sidebar or header
   - Add link back to main dashboard

### Implementation Steps

1. **Copy dashboard.html:**
   ```bash
   cp apps/dashboard/dashboard.html apps/dashboard/fill-the-table.html
   cp apps/dashboard/dashboard.html apps/dashboard/return-to-table.html
   cp apps/dashboard/dashboard.html apps/dashboard/seat-newcomers.html
   ```

2. **Add Campaign Filtering:**
   - In each file, add `CAMPAIGN_FILTER` constant
   - Filter all data by campaign field after loading from Firebase

3. **Update Titles and Headers:**
   - Change page titles
   - Update dashboard headers
   - Update sidebar navigation

4. **Add Campaign-Specific Sections:**
   - Add User Selection Insights section
   - Add Event Selection Insights section
   - Add Matching Insights section
   - Add Message Generation Insights section
   - Add Campaign Metrics section

5. **Add Navigation:**
   - Add links to other campaign dashboards
   - Add link back to main dashboard

6. **Test:**
   - Test Firebase connections
   - Test data display
   - Test navigation
   - Test responsive design

### Firebase Data Structure

All campaigns save data to `/Leo/` paths (same as main dashboard), with each record including a `campaign` field. The schema is based on the Leo automation format used by campaign Python scripts.

**CRITICAL:** The dashboard expects arrays, not objects. The schema must match exactly:

```
/Leo/
├── users/
│   └── {
│       "users": [/* array of user objects */],
│       "count": <number>,
│       "updatedAt": "<ISO timestamp>"
│   }
├── events/
│   └── {
│       "events": [/* array of event objects */],
│       "count": <number>,
│       "updatedAt": "<ISO timestamp>"
│   }
├── matches/
│   └── {
│       "matches": [/* array of match objects */],
│       "count": <number>,
│       "updatedAt": "<ISO timestamp>"
│   }
└── messages/
    └── {
        "messages": [/* array of message objects */],
        "count": <number>,
        "updatedAt": "<ISO timestamp>"
    }
```

**Schema Details:**

Each object in the arrays must include a `campaign` field for filtering:
- `campaign: 'fill-the-table'`
- `campaign: 'return-to-table'`
- `campaign: 'seat-newcomers'`

**How Campaign Scripts Update the Schema:**

Campaign Python scripts (e.g., `fill_the_table.py`, `return_to_table.py`, `seat_newcomers.py`) use the `save_campaign_data_to_firebase()` method which:

1. **Users**: PUT to `/Leo/users` with structure:
   ```json
   {
     "users": [/* array of user objects with campaign field */],
     "count": N,
     "updatedAt": "ISO timestamp"
   }
   ```

2. **Events**: PUT to `/Leo/events` with structure:
   ```json
   {
     "events": [/* array of event objects with campaign field */],
     "count": N,
     "updatedAt": "ISO timestamp"
   }
   ```

3. **Matches**: PATCH to `/Leo/matches` to append (preserves existing matches):
   ```json
   {
     "matches": [/* array of match objects with campaign field */],
     "count": N,
     "updatedAt": "ISO timestamp"
   }
   ```

4. **Messages**: PATCH to `/Leo/messages` to append (preserves existing messages):
   ```json
   {
     "messages": [/* array of message objects with campaign field */],
     "count": N,
     "updatedAt": "ISO timestamp"
   }
   ```

**Key Points:**
- Arrays must be actual arrays (not objects with numeric keys)
- Each object in arrays must include `campaign` field
- `count` field must match array length
- `updatedAt` must be ISO 8601 timestamp (UTC)
- Dashboard reads from `/Leo/` paths, not campaign-specific paths

---

## Dashboard Enhancement Plan

### Overview

This plan outlines improvements to the dashboard HTML file for better local development and enhanced message management functionality.

### Goals

1. Enable local browser testing of `dashboard.html`
2. Fix the Review Button functionality
3. Add an Approve Button (separate from Review modal)
4. Add a Send Button that integrates with notification-api

---

### 1. Open Dashboard in Browser Tab Locally

**Objective:** Enable easy local testing by opening `dashboard.html` in a browser tab.

**Implementation Steps:**

1. **Add Local Server Script:**
   - Create a simple HTTP server script or use Python's built-in server
   - Document the command to run: `python3 -m http.server 8000`
   - Open `http://localhost:8000/dashboard.html` in browser

2. **Update README with Local Development Instructions:**
   - Add section on running locally
   - Include troubleshooting for CORS issues (if any)
   - Document Firebase connection requirements

3. **Optional: Add Browser Tab Opening Script:**
   - Create a shell script that:
     - Starts local server in background
     - Opens browser tab automatically
     - Provides cleanup command

**Files to Modify:**
- `apps/dashboard/README.md` - Add local development section
- `apps/dashboard/dashboard.html` - Ensure it works with file:// protocol or document server requirement

---

### 2. Fix Review Button

**Current Issue:** Review button may not be working correctly or needs improvement.

**Implementation Steps:**

1. **Audit Current Review Button:**
   - Check `openReviewModal()` function in `dashboard.html`
   - Verify button click handlers are properly bound
   - Test with different message statuses

2. **Fix Issues:**
   - Ensure Review button appears for `pending` status messages
   - Fix any JavaScript errors in console
   - Ensure modal opens with correct message data
   - Verify data binding (user name, event name, message text, etc.)

3. **Improvements:**
   - Add loading state when opening modal
   - Add error handling if message data is missing
   - Ensure Review button is disabled for non-pending messages
   - Add keyboard shortcut (e.g., 'R' key) to open review modal

**Files to Modify:**
- `apps/dashboard/dashboard.html` - Fix `openReviewModal()` function and button handlers

**Testing:**
- Test with pending messages
- Test with approved/denied/sent messages (should not show Review button)
- Test with missing data (should handle gracefully)

---

### 3. Add Approve Button

**Objective:** Add a direct Approve button in the message table (in addition to Review modal approve).

**Implementation Steps:**

1. **Add Approve Button to Actions Column:**
   - Show Approve button for `pending` status messages
   - Position next to Review button or as primary action
   - Style with green color scheme

2. **Implement Approve Functionality:**
   - Create `approveMessageDirect(messageId)` function
   - Update Firebase message status to "approved"
   - Add `reviewedAt` timestamp
   - Add `reviewerId` (can be "dashboard_user" or prompt for name)
   - Refresh message list after approval

3. **Add Confirmation:**
   - Optional: Add confirmation dialog before approving
   - Show success message after approval
   - Update metrics immediately

4. **Handle Edge Cases:**
   - Disable button during approval request
   - Show error message if approval fails
   - Handle network errors gracefully

**Files to Modify:**
- `apps/dashboard/dashboard.html` - Add approve button and `approveMessageDirect()` function

**Code Structure:**
```javascript
async function approveMessageDirect(message) {
    // Update Firebase
    // Refresh UI
    // Show success/error
}
```

**Button HTML:**
```html
<button onclick="approveMessageDirect(message)" class="px-3 py-1 bg-green-600 text-white rounded text-sm hover:bg-green-700">
    Approve
</button>
```

---

### 4. Add Send Button (Notification API Integration)

**Objective:** Add a Send button that calls the notification-api to send SMS messages for approved messages.

**Implementation Steps:**

1. **Add Send Button:**
   - Show Send button for `approved` status messages (not yet sent)
   - Hide for `sent` status messages
   - Position in Actions column

2. **Integrate with Notification API:**
   - Add notification API configuration:
     ```javascript
     const NOTIFICATION_API_URL = 'https://api.cuculi.com/notification';
     const AUTH_TOKEN = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9...';
     ```
   - Create `sendMessage(message)` function that:
     - Calls notification API with proper payload
     - Uses message data (userId, text, eventId)
     - Handles authentication (Bearer token)
     - Updates Firebase message status to "sent"
     - Adds `sentAt` timestamp

3. **Notification API Payload:**
   ```javascript
   {
     userId: message.user_id || message.userId,  // MongoDB ObjectId
     type: "chat",
     event: "NEW_MESSAGE",
     configType: "communication",
     targetEntityType: "user",
     channels: ["sms"],
     data: {
       detail: "notification detail",
       senderImage: "https://storage.cuculi.com/production/...",
       userId: message.user_id,
       eventId: message.event_id || message.eventId,
       sender: { id: "5d14a2889c429e40b6039eba" },  // Leo user ID
       timestamp: new Date().toISOString()
     },
     text: message.message_text,  // SMS message text
     createdBy: "5d14a2889c429e40b6039eba"  // Leo user ID
   }
   ```

4. **Error Handling:**
   - Handle API errors (network, authentication, validation)
   - Show user-friendly error messages
   - Retry logic (optional)
   - Log errors to console

5. **Update Firebase After Send:**
   - Update message status to "sent"
   - Add `sentAt` timestamp
   - Add `notificationId` from API response (if available)
   - Refresh message list

6. **UI Feedback:**
   - Disable Send button during request
   - Show loading spinner
   - Show success message
   - Update status badge to "sent"

**Files to Modify:**
- `apps/dashboard/dashboard.html` - Add Send button and `sendMessage()` function

**Reference:**
- `functions/notification-api/README.md` - Full API documentation
- Test with user ID: `631b60819007c60c89083db9`

**Code Structure:**
```javascript
async function sendMessage(message) {
    try {
        // Prepare payload
        const payload = { /* ... */ };
        
        // Call notification API
        const response = await fetch(NOTIFICATION_API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${AUTH_TOKEN}`
            },
            body: JSON.stringify(payload)
        });
        
        if (response.ok) {
            const result = await response.json();
            // Update Firebase message status to "sent"
            // Refresh UI
        } else {
            // Handle error
        }
    } catch (error) {
        // Handle network error
    }
}
```

**Button HTML:**
```html
<button onclick="sendMessage(message)" class="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700">
    Send
</button>
```

---

### Implementation Checklist

- [ ] **Local Development Setup**
  - [ ] Document local server setup
  - [ ] Test dashboard.html in browser
  - [ ] Verify Firebase connection works locally

- [ ] **Review Button Fix**
  - [ ] Audit current Review button functionality
  - [ ] Fix any JavaScript errors
  - [ ] Test with various message statuses
  - [ ] Add error handling

- [ ] **Approve Button**
  - [ ] Add Approve button to Actions column
  - [ ] Implement `approveMessageDirect()` function
  - [ ] Test Firebase update
  - [ ] Add confirmation dialog (optional)
  - [ ] Test error handling

- [ ] **Send Button**
  - [ ] Add Send button to Actions column
  - [ ] Add notification API configuration
  - [ ] Implement `sendMessage()` function
  - [ ] Test API integration
  - [ ] Update Firebase after send
  - [ ] Add error handling
  - [ ] Test with real user ID

- [ ] **Testing**
  - [ ] Test all buttons with different message statuses
  - [ ] Test error scenarios (network failures, API errors)
  - [ ] Verify Firebase updates correctly
  - [ ] Test UI feedback (loading states, success messages)

---

### Testing Instructions

1. **Local Setup:**
   ```bash
   cd apps/dashboard
   python3 -m http.server 8000
   # Open http://localhost:8000/dashboard.html
   ```

2. **Test Review Button:**
   - Find a pending message
   - Click Review button
   - Verify modal opens with correct data
   - Test approve/deny from modal

3. **Test Approve Button:**
   - Find a pending message
   - Click Approve button directly
   - Verify status changes to "approved"
   - Verify Firebase is updated

4. **Test Send Button:**
   - Find an approved message (not yet sent)
   - Click Send button
   - Verify API call is made
   - Verify status changes to "sent"
   - Verify Firebase is updated with `sentAt` timestamp

---

## Testing Checklist

- [ ] Dashboard loads correctly
- [ ] Firebase connection works (reads from correct path)
- [ ] Users display correctly
- [ ] Events display correctly
- [ ] Matches display correctly
- [ ] Messages display correctly
- [ ] Metrics calculate correctly
- [ ] Navigation links work
- [ ] Responsive design works
- [ ] Error handling works

---

## Reference

- **Main Dashboard:** `apps/dashboard/dashboard.html`
- **Campaign Plan:** `plans/monday-2025-12-16/README.md`
- **CEO Approval:** `plans/monday-2025-12-16/CEO_APPROVAL_REQUEST.md`

---

## Original Dashboard Documentation

[Previous documentation continues below...]

---

## User Requirements

### Primary Users

1. **Message Reviewer** (Operations/Marketing Coordinator)
   - Spends hours per week reviewing messages
   - Needs: Speed, clarity, low cognitive load, avoiding mistakes
   - Primary workflow: Review queue → Approve/Deny → Track metrics

2. **Product/Analytics Owner**
   - Monitors dashboard metrics to understand Leo's impact
   - Needs: Approval rate, outreach volume, conversion indicators
   - Uses insights to adjust thresholds and policies

### Functional Requirements

#### 1. Message Review Queue
- **Real-time table** of candidate messages with per-row approve/deny actions
- **Display fields:**
  - Generated message text (truncated with expand option)
  - Associated event (name, date, location)
  - Target user (name, email, phone)
  - Leo's confidence score (0-100%)
  - Current status (pending, approved, denied, sent)
- **Filtering:**
  - By status (pending, approved, denied, sent)
  - By event
  - By reviewer
  - Search by message text, user name, or event name
- **Sorting:** By confidence, date, status

#### 2. Approval/Denial Workflow
- **Single-click Approve:** Updates Firebase status to "approved", triggers downstream send
- **Deny with structured feedback:**
  - Required: Denial reason from controlled vocabulary
    - "Tone Issues"
    - "Incorrect Details"
    - "Wrong User Match"
    - "Policy Violation"
    - "Other"
  - Optional: Reviewer comment (free text)
- **Review modal:** Shows full context (message, user profile, event details, reasoning, confidence)

#### 3. Monitoring Views
- **Events Tab:** View all future events from `/Leo/events`
  - Event name, venue, neighborhood, date, type, capacity
- **Users Tab:** View enriched user profiles from `/Leo/users`
  - Name, email, neighborhood, journey stage, value segment, event count
- **Matches Tab:** View user-event matches from `/Leo/matches`
  - User name, event name, confidence, reasoning, matched timestamp

#### 4. Metrics Dashboard
- **Top-line metrics:**
  - Messages Generated: Total candidate messages created
  - Approval Rate: Approved messages ÷ total reviewed messages (%)
  - Events Assessed: Distinct events with at least one message
  - Users Reached: Unique users who received sent messages
- **Real-time updates:** Metrics refresh automatically as data changes
- **Time period filtering:** Daily, weekly, monthly views (future enhancement)

#### 5. Data Synchronization
- **Real-time updates:** Firebase Realtime Database provides live sync
- **Auto-refresh:** Dashboard polls Firebase every 30 seconds
- **Manual refresh:** Button to force immediate data reload
- **Last updated indicator:** Shows timestamp of most recent data fetch

### Non-Functional Requirements

#### Performance
- **Near real-time updates:** < 1 second latency for Firebase changes
- **Fast response:** Approve/deny actions complete in < 2 seconds
- **Resilience:** Handle network errors gracefully, show loading states

#### Usability
- **Keyboard-friendly:** Support keyboard shortcuts for common actions
- **Mobile-responsive:** Works on tablets (desktop-optimized primary)
- **Accessibility:** WCAG 2.1 AA compliance (future enhancement)
- **Error prevention:** Confirm destructive actions, prevent double-submissions

#### Security & Access
- **Internal tool:** No external authentication required
- **Network-based access control:** VPN or network restrictions
- **Audit trail:** Log reviewer identity (name/email) with each action
- **Read-only by default:** Only approve/deny actions modify data

---

## Technical Specification

### Technology Stack

- **Frontend:** Vanilla HTML/CSS/JavaScript (no build step required)
- **Styling:** Tailwind CSS (CDN)
- **Icons:** Font Awesome 6.4.0 (CDN)
- **Backend:** Firebase Realtime Database (REST API)
- **Deployment:** Static hosting (GitHub Pages, Netlify, or similar)

### Firebase Integration

#### Database Structure

**CRITICAL:** The dashboard expects array-based schema (not object-based). Campaign scripts save data in this format:

```
/Leo/
├── events/
│   └── {
│       "events": [/* array of event objects */],
│       "count": <number>,
│       "updatedAt": "<ISO timestamp>"
│   }
├── users/
│   └── {
│       "users": [/* array of user objects */],
│       "count": <number>,
│       "updatedAt": "<ISO timestamp>"
│   }
├── matches/
│   └── {
│       "matches": [/* array of match objects */],
│       "count": <number>,
│       "updatedAt": "<ISO timestamp>"
│   }
└── messages/
    └── {
        "messages": [/* array of message objects */],
        "count": <number>,
        "updatedAt": "<ISO timestamp>"
    }
```

**Event Object Fields:**
- `id`, `_id`, `name`, `startDate`
- `maxParticipants`, `capacity`, `participants`
- `participantCount`, `participationPercentage`
- `neighborhood`, `categories`, `features`
- `venue`, `venueName`, `type`
- `summary`, `campaign`, `updatedAt`

**User Object Fields:**
- `id`, `_id`, `firstName`, `lastName`, `name`
- `email`, `phone`, `gender`, `birthDay`
- `role`, `status`, `homeNeighborhood`
- `interests`, `occupation`
- `eventCount`, `event_count`
- `journey_stage`, `value_segment`
- `campaign`, `updatedAt`
- Campaign-specific fields (e.g., `newcomer_score`, `reactivation_score`)

**Match Object Fields:**
- `user_name`, `event_name`, `user_id`, `event_id`
- `confidence_percentage`, `reasoning`
- `match_purpose`, `strategy`
- `matched_at`, `campaign`

**Message Object Fields:**
- `message_text`, `user_name`, `user_email`, `user_phone`
- `event_name`, `event_id`
- `similarity_score` (or `confidence_percentage`)
- `reasoning`, `status` (pending, approved, denied, sent)
- `reviewedAt`, `reviewerId`
- `decisionReason`, `reviewerComment`
- `sentAt`, `campaign`
- `generated_at`, `created_at`

#### Firebase Configuration

- **Database URL:** `https://cuculi-2c473.firebaseio.com` (from dashboard.html)
- **Base Path:** `Leo` (for main dashboard)
- **Authentication:** None (open rules for internal development)
- **API:** REST API (GET, PUT, PATCH for updates)

#### API Endpoints Used

```javascript
// Read messages (array-based schema)
GET /Leo/messages.json
// Returns: { messages: [...], count: N, updatedAt: "..." }

// Update message status (update array element)
// First GET to find message, then PUT entire array back
GET /Leo/messages.json
PUT /Leo/messages.json
{
  "messages": [/* updated array with modified message */],
  "count": N,
  "updatedAt": "ISO timestamp"
}

// Read events
GET /Leo/events.json
// Returns: { events: [...], count: N, updatedAt: "..." }

// Read users
GET /Leo/users.json
// Returns: { users: [...], count: N, updatedAt: "..." }

// Read matches
GET /Leo/matches.json
// Returns: { matches: [...], count: N, updatedAt: "..." }
```

**Note:** The dashboard currently uses PUT to update the entire messages array when approving/denying. This is because the schema is array-based, not object-based with individual message IDs.

### Data Flow

```
1. Campaign scripts generate data → Firebase (/campaigns/{campaign-name}/...)
2. Campaign dashboard reads from Firebase → Displays in UI
3. Reviewer approves/denies → Dashboard updates Firebase
4. Downstream system (CuculiMCP) reads approved messages → Sends SMS
5. Send status updated → Dashboard reflects "sent" status
```

### Component Architecture

#### 1. Header Section
- Title and subtitle
- Last updated timestamp
- Refresh button

#### 2. Metrics Bar
- Four metric cards (Messages Generated, Approval Rate, Events Assessed, Users Reached)
- Auto-updating based on current data

#### 3. Tab Navigation
- Messages (default)
- Events
- Users
- Matches

#### 4. Message Queue Table
- Columns: Message, User, Event, Confidence, Status, Actions
- Row actions: Review button (for pending messages)
- Status badges with color coding
- Confidence score with color coding (high ≥80%, medium 60-79%, low <60%)

#### 5. Review Modal
- Full message text
- User context (name, email, phone)
- Event context (name, details)
- Confidence score
- Matching reasoning
- Approve button
- Deny button with reason dropdown
- Cancel button

#### 6. Data Tables (Events, Users, Matches)
- Responsive tables with key fields
- Hover states for better UX
- Empty states with helpful messages

### State Management

- **Client-side state:** All data stored in JavaScript objects
- **No persistence:** Dashboard is stateless, always reads from Firebase
- **Real-time sync:** Polling every 30 seconds (can be upgraded to WebSocket for true real-time)

### Error Handling

- **Network errors:** Show user-friendly error messages
- **Missing data:** Handle null/undefined gracefully
- **Invalid responses:** Validate JSON structure before rendering
- **Failed updates:** Show error alerts, allow retry

### Security Considerations

- **CORS:** Firebase allows cross-origin requests (configured in Firebase rules)
- **Data validation:** Client-side validation before sending updates
- **XSS prevention:** Escape all user-generated content
- **CSRF:** Not applicable (no authentication, internal tool)

### Performance Optimization

- **Lazy loading:** Load data for active tab only (future enhancement)
- **Pagination:** For large datasets (future enhancement)
- **Debouncing:** Search input debounced to reduce API calls
- **Caching:** Browser cache for static assets

### Browser Compatibility

- **Modern browsers:** Chrome, Firefox, Safari, Edge (latest 2 versions)
- **No IE support:** Uses modern JavaScript (ES6+)
- **Mobile:** Responsive design, touch-friendly buttons

---

## Implementation Guide

### Setup Steps

1. **Clone repository:**
   ```bash
   git clone https://github.com/Cuculi-Inc/leo.git
   cd leo/apps/dashboard
   ```

2. **Open dashboard:**
   - Option 1: Open `dashboard.html` directly in browser (for development)
   - Option 2: Serve via local server:
     ```bash
     python3 -m http.server 8000
     # Open http://localhost:8000/dashboard.html
     ```

3. **Configure Firebase (if needed):**
   - Update `FIREBASE_DATABASE_URL` in dashboard HTML files if using different database
   - Update `BASE_PATH` for campaign-specific dashboards

4. **Deploy:**
   - Upload HTML files to static hosting
   - Or serve from web server
   - No build step required

### Key Functions to Implement

#### Data Loading
```javascript
async function loadMessages() {
    const response = await fetch(`${FIREBASE_DATABASE_URL}/${BASE_PATH}/messages.json`);
    const data = await response.json();
    // Parse and store in currentData.messages
    renderMessages();
}
```

#### Approval Action
```javascript
async function approveMessage() {
    const updateData = {
        status: 'approved',
        reviewedAt: new Date().toISOString(),
        reviewerId: getCurrentReviewerId()
    };
    await fetch(`${FIREBASE_DATABASE_URL}/${BASE_PATH}/messages/${messageId}.json`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updateData)
    });
}
```

#### Metrics Calculation
```javascript
function updateMetrics() {
    const totalGenerated = messages.length;
    const approved = messages.filter(m => m.status === 'approved' || m.status === 'sent').length;
    const approvalRate = (approved / totalGenerated) * 100;
    // Update DOM elements
}
```

### Testing Checklist

- [ ] Messages load from Firebase
- [ ] Events, Users, Matches tabs display data
- [ ] Metrics calculate correctly
- [ ] Approval updates Firebase status
- [ ] Denial captures reason and comment
- [ ] Filtering works (status, search)
- [ ] Modal displays full context
- [ ] Refresh button reloads data
- [ ] Error handling for network failures
- [ ] Responsive design on mobile/tablet

### Future Enhancements

1. **Auto-approval:** Approve messages with confidence ≥95% automatically
2. **Batch operations:** Select multiple messages for bulk approve/deny
3. **Advanced filtering:** Date ranges, confidence thresholds
4. **Export:** Download CSV of reviewed messages
5. **Analytics:** Charts showing approval trends over time
6. **User authentication:** Login system for audit trails
7. **WebSocket:** Real-time updates instead of polling
8. **Edit capability:** Edit message text before approving
9. **A/B testing:** Test different message variations
10. **RSVP attribution:** Link sent messages to actual RSVPs

---

## Design Guidelines

### Color Scheme
- **Primary:** Indigo (#4F46E5) for actions and highlights
- **Success:** Green (#059669) for approved/sent
- **Warning:** Yellow (#D97706) for medium confidence
- **Error:** Red (#DC2626) for denied/low confidence
- **Neutral:** Gray scale for text and backgrounds

### Typography
- **Font:** Inter (Google Fonts)
- **Headings:** Bold, 600-700 weight
- **Body:** Regular, 400 weight
- **Code/IDs:** Monospace for technical data

### Spacing
- **Consistent padding:** 4px, 8px, 16px, 24px scale
- **Card spacing:** 16px between cards
- **Table padding:** 24px horizontal, 16px vertical

### Components
- **Buttons:** Rounded corners (8px), hover states, disabled states
- **Badges:** Pill-shaped, color-coded by status
- **Tables:** Alternating row colors, hover highlights
- **Modals:** Backdrop blur, centered, max-width constraints

### Accessibility
- **Keyboard navigation:** Tab through interactive elements
- **Focus states:** Visible focus indicators
- **ARIA labels:** Screen reader support (future enhancement)
- **Color contrast:** WCAG AA compliant

---

## Integration with Leo Workflows

The dashboard integrates with the following Leo workflows:

1. **Campaign Scripts** → Populate `/campaigns/{campaign-name}/events`, `/campaigns/{campaign-name}/users`, `/campaigns/{campaign-name}/matches`, `/campaigns/{campaign-name}/messages` (status: "pending")
2. **Dashboard** → Updates `/campaigns/{campaign-name}/messages` (status: "approved" or "denied")
3. **CuculiMCP** → Reads approved messages, sends SMS, updates status to "sent"

### Workflow Sequence

```
MongoDB → Campaign Script → /campaigns/{campaign-name}/events
MongoDB → Campaign Script → /campaigns/{campaign-name}/users
Firebase → Campaign Script → /campaigns/{campaign-name}/matches
Firebase → Campaign Script → /campaigns/{campaign-name}/messages (pending)
Dashboard → Human Review → /campaigns/{campaign-name}/messages (approved/denied)
Firebase → CuculiMCP → SMS Delivery → /campaigns/{campaign-name}/messages (sent)
```

---

## Success Metrics

### Business Metrics
- **RSVP Rate:** % of users who RSVP after receiving approved message
- **Event Fill Rate:** % of event capacity filled
- **User Engagement:** Increase in app activity after message receipt

### Operational Metrics
- **Messages Generated:** Total candidates created by campaign
- **Approval Rate:** % of messages approved by reviewers
- **Review Time:** Average time to review a message
- **Events Assessed:** Number of distinct events with messages
- **Users Reached:** Unique users who received sent messages

### Quality Metrics
- **Denial Rate by Reason:** Track which issues are most common
- **Confidence vs Approval:** Correlation between confidence and approval
- **Reviewer Consistency:** Agreement between reviewers on similar messages

---

## Support & Maintenance

### Troubleshooting

**Messages not loading:**
- Check Firebase URL and base path (`/Leo/`)
- Verify campaign filter is working (check `campaign` field on records)
- Verify CORS settings in Firebase
- Check browser console for errors
- Verify network connectivity

**Approval not updating:**
- Check Firebase write permissions
- Verify message ID/key is correct
- Check browser console for PATCH errors

**Metrics incorrect:**
- Verify data structure matches expected schema
- Check calculation logic in `updateMetrics()`
- Ensure status values match expected strings

### Maintenance Tasks

- **Weekly:** Review error logs, check Firebase quota
- **Monthly:** Update documentation, review metrics trends
- **Quarterly:** User feedback collection, feature prioritization

---

## References

- [Firebase Realtime Database REST API](https://firebase.google.com/docs/database/rest/start)
- [Human-in-the-Loop Best Practices](https://cloud.google.com/discover/human-in-the-loop)
- [Dashboard Design Principles](https://www.nngroup.com/articles/dashboard-design/)
- [Leo Workflow Documentation](../../README.md)

---

## License

Proprietary - Cuculi Inc.
